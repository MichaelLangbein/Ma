\section{Javascript}

\subsection{The js-runtime}

\subsection{Module system}

\subsection{Promises, async-await and rxjs}
\inlinecode{async} - \inlinecode{await} lets you handle asynchronous code as if it was synchronous. 

\subsection{Webworkers: multithreading}


\subsection{WebGL}

\subsubsection{Shaders}
\paragraph{The vertrex shader} is called once for every vertex. It does some transformation on the vertex to add perspective and then stores the result in \inlinecode{gl_Position}. 
\paragraph{The ragment shader} is called once for every pixel on every shape. It determines the pixel's color (\inlinecode{gl_FragColor}) by
\begin{itemize}
    \item which pixel of a texture belongs here, 
    \item applying lighting
\end{itemize} 

\paragraph{attributes} In WebGL, values that apply to a specific vertex are stored in attributes. These are only available to the JavaScript code and the vertex shader. Attributes are referenced by an index number into the list of attributes maintained by the GPU. 
Since attributes cannot be used unless enabled, and are disabled by default, you need to call \inlinecode{enableVertexAttribArray()} to enable individual attributes so that they can be used. Once that's been done, other methods can be used to access the attribute, including \inlinecode{vertexAttribPointer(), vertexAttrib*()}, and \inlinecode{getVertexAttrib()}.

\paragraph{Buffers} are the way of getting vertex and other per vertex data onto the GPU. 
\begin{itemize}
    \item \inlinecode{gl.createBuffer} creates a buffer. 
    \item \inlinecode{gl.bindBuffer} sets that buffer as the buffer to be worked on. 
    \item \inlinecode{gl.bufferData} copies data into the buffer. 
\end{itemize}
This is usually done at initialization time.

Once the data is in the buffer we need to tell WebGL how to get data out of it and provide it to the vertex shader's attributes.

To do this, first we ask WebGL what locations it assigned to the attributes. For example in the code above we have
\begin{lstlisting}[language=c]
    // look up where the vertex data needs to go.
    var positionLocation = gl.getAttribLocation(program, "a_position");
    var colorLocation = gl.getAttribLocation(program, "a_color");
\end{lstlisting}
This is also usually done at initialization time.

Once we know the location of the attribute we then issue 3 commands just before drawing.
\begin{lstlisting}[language=c]
    // That command tells WebGL we want to supply data from a buffer.
    gl.enableVertexAttribArray(location);

    // That command binds a buffer to the ARRAY_BUFFER bind point. 
    // It's a global variable internal to WebGL
    gl.bindBuffer(gl.ARRAY_BUFFER, someBuffer);


    //  And that command tells WebGL to get data from the buffer that is 
    // currently bound to the ARRAY_BUFFER bind point, how many components per vertex (1 - 4), 
    // what the type of data is (BYTE, FLOAT, INT, UNSIGNED_SHORT, etc...), 
    // the stride which means how many bytes to skip to get from one piece of data 
    // to the next piece of data, and an offset for how far into the buffer our data is.
    gl.vertexAttribPointer(
        location,
        numComponents,
        typeOfData,
        normalizeFlag,
        strideToNextPieceOfData,
        offsetIntoBuffer);
\end{lstlisting}

Number of components is always 1 to 4. If you are using 1 buffer per type of data then both stride and offset can always be 0. 0 for stride means "use a stride that matches the type and size". 0 for offset means start at the beginning of the buffer. Setting them to values other than 0 is more complicated and though it has some benefits in terms of performance it's not worth the complication unless you are trying to push WebGL to its absolute limits.



\subsection{WASM}
\begin{itemize}
    \item If wasm does not get a garbage-collector, 
        \begin{itemize}
            \item there will be no easy way for non-gc languages to run in wasm. They need to bring their own gc (or even runtime) with them (like c\# does now). 
            \item In that case, a situation like python + numy will probably evolve.
        \end{itemize}
    \item If wasm will not allow DOM-manipulation, 
        \begin{itemize}
            \item then there really is no point for non nummeric-focussed languages to be implemented in wasm.
            \item In that case, a situation like python + numy will probably evolve.
        \end{itemize}
    \item If, however, wasm will get a gc and allow DOM-manipulation, 
        \begin{itemize}
            \item Then python, ruby etc. will all develop angular-clones to run on the web. 
            \item However, given the large js-ecosystem, those will not kick in too mightily. 
        \end{itemize}
\end{itemize}

\subsection{Typescript}

\subsubsection{Building}

\subsubsection{Module resolution}