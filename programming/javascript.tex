\section{Javascript}
At its heart, javascript is a simple language. Its has however two very unconventional features that are not used in any other languages: \emph{this} and \emph{prototpye}s.  

 \paragraph{this}: every function implicity gets a parameters named \inlinecode{this}, containing the context. 
\begin{lstlisting}
    function add (x, y) {
        console.log(this);
        return x + y;
    }
\end{lstlisting}
The context \inlinecode{this} can also be explicitly assigned.
\begin{lstlisting}
    const add3 = add.bind("michael", 2);
\end{lstlisting}
Note that this does not work for arrow-functions, which keep their once assigned context!


\paragraph{prototype}: Prototype-languages should really only achieve inheritance by copying objects. Javascript implements this badly, though, because it offers \emph{two} means of inheritance: object-copying and constructor-functions.
\begin{itemize}
    \item Instances 
        \begin{itemize}
            \item Every object has a \inlinecode{.__proto__}. 
            \item \inlinecode{.__proto__} contains the list of inherited props and methods and \emph{should} not be modified.
        \end{itemize}
    \item Constructing new objects
        \begin{itemize}
            \item With \inlinecode{Object.create}: passing \inlinecode{theObject.__proto__} and \inlinecode{theObject}'s instance-properties.
                \begin{itemize}
                    \item Calling \inlinecode{const vender = Object.create(bender); vender.name = 'Vender';} will give \inlinecode{vender} these properties: \inlinecode{bender.__proto__} and \inlinecode{bender}'s instance-properties;
                \end{itemize}
            \item With constructor functions: passing \inlinecode{TheFunction.prototype}
                \begin{itemize}
                    \item Functions are objects, so they, too, have a \inlinecode{.__proto__}
                    \item Additionally, functions have a \inlinecode{.prototype}. This is because any function may serve as a constructor, so they need this \inlinecode{.prototype}.
                    \item Even though not all functions are intended as constructors, js expects them to be that. So every function can be called with \inlinecode{new}. Doing this expects the function to do two things:
                        \begin{itemize}
                            \item it expects to have the function assign some things to its internal \inlinecode{this}. These assignments will be instance-properties.
                            \item it expects \inlinecode{TheFunction.prototype} to have a few props that are to be shared between all instances.
                        \end{itemize}
                    \item Contrary to \inlinecode{.__proto__}, \inlinecode{.prototype} may and should be modified.
                    \item So, calling \inlinecode{const bender = new Robot('Bender');} will give \inlinecode{bender} these properties: \inlinecode{Robot.prototype};
                \end{itemize}
            \item Funfact: \inlinecode{Object} is a constructor-function, which is why there is a \inlinecode{Object.prototype}. Indeed, calling \inlinecode{{name: 'Michael'}} is shorthand for \inlinecode{new Object({name: 'Michael'})} 
        \end{itemize}
\end{itemize}

\begin{lstlisting}
const Robot = function(name) {
    this.name = name;
}
Robot.prototype.sayHi = function() {
    return 'Hi from ' + this.name;
};
const bender = new Robot('Bender');
bender.sayHi();
Robot.prototype.sayHi = function() {
    return 'Bugger off from ' + this.name;
}
bender.sayHi();
\end{lstlisting}

\subsection{The js-runtime}

\subsection{Module system}

\begin{table}[ht]
\begin{tabularx}{1.2\textwidth}{XXXXXX}
                    & CommonJs                                                            & NodeJs                                                                   & AMD                  & UMD                    & ES2015 aka. ES6                                           \\
    used by         & formerly node                                                       & node                                                                     & requirejs            &                        &                                                           \\
    module-file     & \inlinecode{exports.area = (r) =\textgreater PI * r * r;}           & \inlinecode{module.exports = \{area: (r) =\textgreater PI * r * r; \}}   & \inlinecode{define}  & First tries AMD, then commonJs, then exports as global.         & \inlinecode{export const sqrt = Math.sqrt;}               \\
    user-file       & \inlinecode{const module = require('./module.js'); module.area(4);} & \inlinecode{const module = require('./module.js'); module.area(4);}      & \inlinecode{require} &                        & \inlinecode{\textbf\{import \{ sqrt \} from 'module';\}}  \\
    loads modules   & synchronously                                                       & synchronously                                                            & asynchronously       &                        &                                                           \\
    implementations & webpack, browserify                                                 & node, webpack, browserify                                                & requirejs            &                        & webpack, babel                                            \\
    Notes           & Used to be a candidate for node, but now abandoned.                 &                                                                          &                      &                        & Official JS standard, but so far not implemented in any browser or nodejs.
\end{tabularx}
\end{table}

\subsubsection{Building with webpack}
My builder of choice is webpack. Basically, webpack makes ES6-import and -export work. There is some nice documentation \href{https://what-problem-does-it-solve.com/webpack/index.html}{here}.

paragraph{General concepts}: Some concepts and nomenclature.

\begin{itemize}
    \item Loaders vs Plugins: loaders work on the individual file-level, plugins work at the bundle- or chunk-level.
\end{itemize}

\paragraph{Module-resolution}: Webpack can work with most module-types that javascript has to offer.

\begin{itemize}
    \item Javascript: webpack works fine with commonJs, nodeJs, and AMD, but will sometimes have problems with UMD.
    \item Other languages: how to resolve other languages (ts, sass, shader, ...) is left over to loaders.
\end{itemize}

\paragraph{Shimming}: Webpack only loads a module when it sees it required at some point. This makes for smaller bundles, of course, but here is one problem this can cause. Say you have a dependency to jQuery and bootstrap. JQuery exposes \inlinecode{window.\$} as a global object. Bootstrap requires there to be a global \inlinecode{window.\$} object. However, since bootstrap just assumes that \inlinecode{window.\$} is there without ever calling \inlinecode{import}, webpack won't resolve the dependency and never include jQuery in the package. To avoid such problems, there is something called \emph{shimming}. 

\begin{lstlisting}
plugins: [
    new CopywebpackPlugin([ \{ from: path.resolve(__dirname, 'node_modules/cesium/Build/Cesium/Workers'), to: 'Workers' \} ]),
    new CopywebpackPlugin([ \{ from: path.resolve(__dirname, 'node_modules/cesium/Source/Assets'), to: 'Assets' \} ]),
    new CopywebpackPlugin([ \{ from: path.resolve(__dirname, 'node_modules/cesium/Source/Widgets'), to: 'Widgets' \} ]),
    new webpack.DefinePlugin(\{
        CESIUM_BASE_URL: JSON.stringify(''),
    \}),
    new webpack.ProvidePlugin(\{
        Cesium: 'cesium/Build/Cesium/Cesium'
    \})
],
\end{lstlisting}

The \inlinecode{ProviderPlugin} makes Cesium available to the global workspace. If you don't want this, you might want to instead use the \inlinecode{module.rules.imports-loader}.

\paragraph{Path-resolution}: When you ask to import a string that doesn't have a leading \inlinecode{./}, it tells Webpack: "Look for the file everywhere on my hard drive except the current directory". I'm not kidding. You can see the output desperately climbing up your directory hierarchy looking for a directory called \inlinecode{node_modules} in which it hopes to find index.js.
When you precede the module name with a \inlinecode{./}, it tells Webpack to look in the current directory for the file. So, the rule of thumb is: your code usually has a ./ and third-party libraries don't.


\paragraph{How webpack does it}
Webpack compiles this code:
\begin{lstlisting}
// helpers.ts
export function sayHi(name: string): string {
    return `Hi, ${name}!`;
}

// index.ts
import { sayHi } from "./helpers";
console.log(sayHi('Michael'));
\end{lstlisting}

to this code: 
\begin{lstlisting}
// self calling function
(function(modules) {
        // The module cache
        var installedModules = {};
    
        // The require function
        function __webpack_require__(moduleId) {
    
            // Check if module is in cache
            if(installedModules[moduleId]) {
                return installedModules[moduleId].exports;
            }
            // Create a new module (and put it into the cache)
            var module = installedModules[moduleId] = {
                i: moduleId,
                l: false,
                exports: {}
            };
    
            // Execute the module function
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    
            // Flag the module as loaded
            module.l = true;
    
            // Return the exports of the module
            return module.exports;
        }
    
        // expose the modules object (__webpack_modules__)
        __webpack_require__.m = modules;
    
        // expose the module cache
        __webpack_require__.c = installedModules;
    
        // define getter function for harmony exports
        __webpack_require__.d = function(exports, name, getter) {
            if(!__webpack_require__.o(exports, name)) {
                Object.defineProperty(exports, name, { enumerable: true, get: getter });
            }
        };
    
        // define __esModule on exports
        __webpack_require__.r = function(exports) {
            if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
            }
            Object.defineProperty(exports, '__esModule', { value: true });
        };
    
        // create a fake namespace object
        // mode & 1: value is a module id, require it
        // mode & 2: merge all properties of value into the ns
        // mode & 4: return value when already ns object
        // mode & 8|1: behave like require
        __webpack_require__.t = function(value, mode) {
            if(mode & 1) value = __webpack_require__(value);
            if(mode & 8) return value;
            if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            var ns = Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, 'default', { enumerable: true, value: value });
            if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
            return ns;
        };
    
        // getDefaultExport function for compatibility with non-harmony modules
        __webpack_require__.n = function(module) {
            var getter = module && module.__esModule ?
                function getDefault() { return module['default']; } :
                function getModuleExports() { return module; };
            __webpack_require__.d(getter, 'a', getter);
            return getter;
        };
    
        // Object.prototype.hasOwnProperty.call
        __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    
        // __webpack_public_path__
        __webpack_require__.p = "";
    
    
        // Load entry module and return exports
        return __webpack_require__(__webpack_require__.s = 0);
    })({
    
        // dependency
        "./src/dependency.ts": (function(module, __webpack_exports__, __webpack_require__) {
            function sayHi(name) {
                return "Hi, " + name + "!";
            }
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, "sayHi", function() { return sayHi; })
        }),
    
        // script 
        "./src/index.ts": (function(module, __webpack_exports__, __webpack_require__) {
            __webpack_require__.r(__webpack_exports__);
            var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/helpers.ts");
            console.log(Object(_helpers__WEBPACK_IMPORTED_MODULE_0__["sayHi"])('Michael'));
        })
});
\end{lstlisting}


\subsection{Promises, async-await and rxjs}
\inlinecode{async} - \inlinecode{await} lets you handle asynchronous code as if it was synchronous. 

\subsection{Webworkers: multithreading}


\subsection{WASM}
\begin{itemize}
    \item If wasm does not get a garbage-collector, 
        \begin{itemize}
            \item there will be no easy way for non-gc languages to run in wasm. They need to bring their own gc (or even runtime) with them (like c\# does now). 
            \item In that case, a situation like python + numy will probably evolve.
        \end{itemize}
    \item If wasm will not allow DOM-manipulation, 
        \begin{itemize}
            \item then there really is no point for non nummeric-focussed languages to be implemented in wasm.
            \item In that case, a situation like python + numy will probably evolve.
        \end{itemize}
    \item If, however, wasm will get a gc and allow DOM-manipulation, 
        \begin{itemize}
            \item Then python, ruby etc. will all develop angular-clones to run on the web. 
            \item However, given the large js-ecosystem, those will not kick in too mightily. 
        \end{itemize}
\end{itemize}


