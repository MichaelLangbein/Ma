\section{Javascript}
At its heart, javascript is a simple language. Its has however two very unconventional features that are not used in any other languages: \emph{this} and \emph{prototpye}s.  

 \paragraph{this}: every function implicity gets a parameters named \inlinecode{this}, containing the context. 
\begin{lstlisting}
    function add (x, y) {
        console.log(this);
        return x + y;
    }
\end{lstlisting}
The context \inlinecode{this} can also be explicitly assigned.
\begin{lstlisting}
    const add3 = add.bind("michael", 2);
\end{lstlisting}
Note that this does not work for arrow-functions, which keep their once assigned context!


\paragraph{prototype}: Prototype-languages should really only achieve inheritance by copying objects. Javascript implements this badly, though, because it offers \emph{two} means of inheritance: object-copying and constructor-functions.
\begin{itemize}
    \item Instances 
        \begin{itemize}
            \item Every object has a \inlinecode{.__proto__}. 
            \item \inlinecode{.__proto__} contains the list of inherited props and methods and \emph{should} not be modified.
        \end{itemize}
    \item Constructing new objects
        \begin{itemize}
            \item With \inlinecode{Object.create}: passing \inlinecode{theObject.__proto__} and \inlinecode{theObject}'s instance-properties.
                \begin{itemize}
                    \item Calling \inlinecode{const vender = Object.create(bender); vender.name = 'Vender';} will give \inlinecode{vender} these properties: \inlinecode{bender.__proto__} and \inlinecode{bender}'s instance-properties;
                \end{itemize}
            \item With constructor functions: passing \inlinecode{TheFunction.prototype}
                \begin{itemize}
                    \item Functions are objects, so they, too, have a \inlinecode{.__proto__}
                    \item Additionally, functions have a \inlinecode{.prototype}. This is because any function may serve as a constructor, so they need this \inlinecode{.prototype}.
                    \item Even though not all functions are intended as constructors, js expects them to be that. So every function can be called with \inlinecode{new}. Doing this expects the function to do two things:
                        \begin{itemize}
                            \item it expects to have the function assign some things to its internal \inlinecode{this}. These assignments will be instance-properties.
                            \item it expects \inlinecode{TheFunction.prototype} to have a few props that are to be shared between all instances.
                        \end{itemize}
                    \item Contrary to \inlinecode{.__proto__}, \inlinecode{.prototype} may and should be modified.
                    \item So, calling \inlinecode{const bender = new Robot('Bender');} will give \inlinecode{bender} these properties: \inlinecode{Robot.prototype};
                \end{itemize}
            \item Funfact: \inlinecode{Object} is a constructor-function, which is why there is a \inlinecode{Object.prototype}. Indeed, calling \inlinecode{{name: 'Michael'}} is shorthand for \inlinecode{new Object({name: 'Michael'})} 
        \end{itemize}
\end{itemize}

\begin{lstlisting}
const Robot = function(name) {
    this.name = name;
}
Robot.prototype.sayHi = function() {
    return 'Hi from ' + this.name;
};
const bender = new Robot('Bender');
bender.sayHi();
Robot.prototype.sayHi = function() {
    return 'Bugger off from ' + this.name;
}
bender.sayHi();
\end{lstlisting}

\subsection{The js-runtime}

\subsection{Module system}

\begin{table}[h]
    \begin{tabularx}{1.2*\textwidth}{XXXXXX}
                    & CommonJs                                                            & NodeJs                                                                   & AMD            & UMD                    & ES2015 aka. ES6                                           \\
    used by         & formerly node                                                       & node                                                                     & requirejs      &                        &                                                           \\
    module-file     & \inlinecode{exports.area = (r) =\textgreater PI * r * r;}           & \inlinecode{module.exports = \{area: (r) =\textgreater PI * r * r; \}}   &                & First tries AMD, then commonJs, then exports as global.         & \inlinecode{export const sqrt = Math.sqrt;}               \\
    user-file       & \inlinecode{const module = require('./module.js'); module.area(4);} & \inlinecode{const module = require('./module.js'); module.area(4);}      &                &                        & \inlinecode{\textbf\{import \{ sqrt \} from 'module';\}}  \\
    loads modules   & synchronously                                                       & synchronously                                                            & asynchronously &                        &                                                           \\
    implementations & webpack, browserify                                                 & node, webpack, browserify                                                & requirejs      &                        & webpack, babel                                            \\
    Notes           & Used to be a candidate for node, but now abandoned.                 &                                                                          &                &                        & Official JS standard, but so far not implemented in any browser or nodejs.
    \end{tabularx}
\end{table}

\subsubsection{Building}
My builder of choice is webpack. 



\subsection{Promises, async-await and rxjs}
\inlinecode{async} - \inlinecode{await} lets you handle asynchronous code as if it was synchronous. 

\subsection{Webworkers: multithreading}


\subsection{WASM}
\begin{itemize}
    \item If wasm does not get a garbage-collector, 
        \begin{itemize}
            \item there will be no easy way for non-gc languages to run in wasm. They need to bring their own gc (or even runtime) with them (like c\# does now). 
            \item In that case, a situation like python + numy will probably evolve.
        \end{itemize}
    \item If wasm will not allow DOM-manipulation, 
        \begin{itemize}
            \item then there really is no point for non nummeric-focussed languages to be implemented in wasm.
            \item In that case, a situation like python + numy will probably evolve.
        \end{itemize}
    \item If, however, wasm will get a gc and allow DOM-manipulation, 
        \begin{itemize}
            \item Then python, ruby etc. will all develop angular-clones to run on the web. 
            \item However, given the large js-ecosystem, those will not kick in too mightily. 
        \end{itemize}
\end{itemize}


