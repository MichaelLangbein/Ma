\section{Angular}

\begin{itemize}
    \item Module: lists all components (\inlinecode{declarations}) and all dependencies (\inlinecode{imports})
    \item Component: Defines a custom html-Tag
    \item Service: accesses a server
\end{itemize}

\subsection{Components}

A component consists of a html-template and a ts-class. The template can access the classes properties and methods through directives.
These directives are special syntax like \inlinecode{\{\}} or \inlinecode{*ngIf} that contain a string of ts-code that can be evaluated in the context of the class.
It makes sense to think of a component as a way to view your model, not as directly related to the model itself. For example, if your model is a joke, you might have the components JokeDetail, JokeList, and JokeAdd.

\begin{itemize}
    \item ts-file: has a method for every lifecycle-hook and a property for every bindable data.
    \item html-file:
            \begin{itemize}
                \item interpolation: curly braces can read a classes properties. \inlinecode{<li>\{\{hero.name | uppercase\}\}</li>}
                \item input-binding: round braces capture input-events. \inlinecode{(click)="onSelect(hero)"} Captures an input and directs to a method. The event has been emitted through \inlinecode{@Output() out: Emitter<number>()}
                \item value-binding: square braces write to a classes properties. \inlinecode{[hero]="chosenHero"} assigns an object to a property. The input is set through \inlinecode{@Input() prop;}
                \item two-way-binding: for reading \emph{and} writing properties. \inlinecode{[(ngModel)]="hero.name"}, requires \inlinecode{FormsModule}
                \item loops: \inlinecode{*ngFor="let hero of heroes"}
                \item conditionals: \inlinecode{*ngIf="!selected"}
            \end{itemize}
            Together, these might make a code section like this: \inlinecode{<li *ngFor="let hero of heroes" (click)="onSelect(hero)">\{\{hero.id\}\} -- \{\{hero.name\}\}</li>}
\end{itemize}

\subsubsection{Template directives: details}

\paragraph{*ngFor}

\paragraph{*ngIf} 



\subsection{Directives}
Directives are essentially components without a template. 
\subsubsection{Attribute-directives}
Instead of exposing a new custom html-element (as components do), attribute-directives expose a new custom \emph{attribute} that we may add to any html-element. 
Here is an example of an attribute-directive in its simplest form: \href{}{}.
Very often, you will want to create attribute-directives that fire events. This is where the \inlinecode{@Output} annotation comes into play. See this example: 
\begin{lstlisting}[language=java]
    import { Directive, Output, EventEmitter, ElementRef, HostListener } from '@angular/core';


    @Directive({
      selector: '[guClickOutside]'
    })
    export class ClickOutsideInsideDirective {
      
      @Output() guClickOutside = new EventEmitter<MouseEvent>();
      @Output() guClickInside = new EventEmitter<MouseEvent>();
      
      constructor(
        private elementRef: ElementRef
      ) { }
    
      @HostListener('document:click', ['$event'])
      public onDocumentClick(event: MouseEvent): void {
        const targetElement = event.target as HTMLElement;
        if (targetElement && !this.elementRef.nativeElement.contains(targetElement)) {
          this.guClickOutside.emit(event);
        } else {
          this.guClickInside.emit(event);
        }
      }
    }
\end{lstlisting}
This directive can be used inside any component like so: 
\begin{lstlisting}[language=java]
    <gu-moveable 
        [xPos]="xPos" [yPos]="yPos"  
        ClickOutsideInsideDirective (guClickOutside)="onClickOutside($event)" 
        ClickOutsideInsideDirective (guClickInside)="onClickInside($event)"
    > ...
\end{lstlisting}


\subsection{Routing}
Routing is usually done in a separate module. It consist of two parts: 
\begin{itemize}
    \item The route definition, consisting of a path and the component that is to be displayed under that path.
    \item The html-links
\end{itemize}
As a side effect, when you decide to use routes, not all components need to be subcomponents of \inlinecode{app-component} anymore.

Configuring routing requires three steps. First, configure the routing in your \inlinecode{app.componnent.ts}: 
\begin{lstlisting}[language=java]
    import { RouterModule, Routes } from '@angular/router';
    
    const routes: Routes = [
      {path: "", component: JokeListComponent},
      {path: "details/:id", component: JokeComponent},
      {path: "overview", component: JokeListComponent},
      {path: "add", component: JokeAddComponent}
    ];
    
    @NgModule({
      imports: [
        BrowserModule,
        HttpClientModule,
        RouterModule.forRoot(routes)
      ]
    })
    export class AppModule { }
\end{lstlisting}

Second, change your \inlinecode{app.componnent.html} to include the router-outlet:
\begin{lstlisting}[language=html]
    <h1>Welcome to {{title}}!</h1>
    <router-outlet></router-outlet>
\end{lstlisting}

Third, make use of the routing:
\begin{itemize}
    \item creating a reference: \inlinecode{<a routerLink="details/\{\{joke.id\}\}">\{\{joke.title\}\}</a>}
    \item getting data from a reference: 
        \begin{lstlisting}[language=java]
            import {ActivatedRoute} from "@angular/router";

            constructor(private route: ActivatedRoute) {
                let id = this.route.snapshot.paramMap.get('id');
            }
        \end{lstlisting}
        Or, if you want to continue observing the url:
        \begin{lstlisting}[language=java]
            import {ActivatedRoute} from "@angular/router";

            constructor(private route: ActivatedRoute) {
                this.route.params.subscribe( params => console.log(params) );
            }
        \end{lstlisting}
\end{itemize}


\subsection{Modules}
You create modules when you want to create some functionality that might be shared via npm. 
Modules are always imported into angular in the form of a class. To import your module into a site, 
\begin{itemize}
    \item download the module with npm
    \item \inlinecode{ng generate module <yourmodule>}
    \item add the module to the app-modules \inlinecode{import}s
    \item in \inlinecode{<yourmodule>.module.ts}, 
        \begin{itemize}
            \item create a class \inlinecode{<Yourmodule>Module}
            \item configure that class with \inlinecode{@ngModule}
            \item export the class
        \end{itemize}
\end{itemize}


\subsection{Services}
Services are data providers. They do not have to call REST-interfaces. They might call a database or a file, or they might be used as a messaging service between components, or they might be a way for all your components to access the global game-state. But if they do happen to call a REST-service, they typically return an observable.





\subsection{Component interaction}
Usually, components will interact with each other by using a service, especially then when some shared data is held by that service (like state, a database or simmilar). Sometimes however, it makes sense to let components access each other more directly, especially when we're dealing with a parent-child relationship.

\subsubsection{Subcomponents obtaining data from parent-template through Input}
Subcomponents can obtain the values of their properties from supercomponents. 

A component-class can have properties annotated with \inlinecode{@Input}. That means that the value of this property will be given through the components html-tag. 
For example, the component \inlinecode{Heroes} might have this tag in its template:

\begin{lstlisting}[language=html]
    <li *ngFor="let chosenHero of heroes"> 
        <app-hero-detail [hero]="chosenHero"></app-hero-detail>
    <li>
\end{lstlisting}

This \inlinecode{chosenHero} would be bound to the \inlinecode{hero} property in the \inlinecode{HeroDetail} component.

\begin{lstlisting}[language=java]
export class HeroDetailComponent implements OnInit {

  @Input()
  hero: Hero;

  constructor() {}
  ngOnInit() {}
}
\end{lstlisting}

\subsubsection{Child notifying parent through EventEmitter}
Children may annotate some properties with \inlinecode{@Output}.
\begin{lstlisting}[language=java]
@Component({
    selector: 'app-voter',
    template: `
        <h4>{{name}}</h4>
        <button (click)="vote(true)"  [disabled]="didVote">Agree</button>
        <button (click)="vote(false)" [disabled]="didVote">Disagree</button>
    `
})
export class VoterComponent {
    @Input()  name: string;
    @Output() voted = new EventEmitter<boolean>();
    didVote = false;
    
    vote(agreed: boolean) {
        this.voted.emit(agreed);
        this.didVote = true;
    }
}
\end{lstlisting}

With the \inlinecode{@Output} annotation, a new input-binding is available for the parents template: \inlinecode{(voted)}.
\begin{lstlisting}[language=java]
@Component({
    selector: 'app-vote-taker',
    template: `
        <h2>Should mankind colonize the Universe?</h2>
        <h3>Agree: {{agreed}}, Disagree: {{disagreed}}</h3>
        <app-voter *ngFor="let voter of voters"
        [name]="voter"
        (voted)="onVoted($event)">
        </app-voter>
    `
})
export class VoteTakerComponent {
    agreed = 0;
    disagreed = 0;
    voters = ['Mr. IQ', 'Ms. Universe', 'Bombasto'];
    
    onVoted(agreed: boolean) {
        agreed ? this.agreed++ : this.disagreed++;
    }
}
\end{lstlisting}


\subsubsection{Supercomponents calling child-methods directly through ViewChild}
On the other hand, sometimes a component needs access to it's children. A component can access its child-components with the \inlinecode{@ViewChildren} property-annotation.
\begin{lstlisting}[language=java]
import { CountdownTimerComponent }  from './countdown-timer.component';
 
@Component({
  selector: 'app-countdown-parent-vc',
  template: `
  <h3>Countdown to Liftoff (via ViewChild)</h3>
  <button (click)="start()">Start</button>
  <button (click)="stop()">Stop</button>
  <div class="seconds">{{ seconds() }}</div>
  <app-countdown-timer></app-countdown-timer>
  `,
  styleUrls: ['../assets/demo.css']
})
export class CountdownViewChildParentComponent implements AfterViewInit {
 
  @ViewChild(CountdownTimerComponent)
  private timerComponent: CountdownTimerComponent;
 
  seconds() { return 0; }
 
  ngAfterViewInit() {
    // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...
    // but wait a tick first to avoid one-time devMode
    // unidirectional-data-flow-violation error
    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);
  }
 
  start() { this.timerComponent.start(); }
  stop() { this.timerComponent.stop(); }
}
\end{lstlisting}


\subsubsection{Childcomponents don't need to know that their @Input is passed in asynchronously}

\begin{lstlisting}[language=java, caption=Parent]
  @Component({
    selector: 'app-parent',
    template: `
      This is the parent compoent. 
      <app-child [val]="value | async"></app-child>
    `
  })
  export class ParentComponent implements OnInit {
    value: Subject<number> = new Subject<number>();
    ngOnInit() {
      window.setInterval(() => this.value.next( Math.random() ), 1000);
    }
  }
\end{lstlisting}

\begin{lstlisting}[language=java, caption=Child]
  @Component({
    selector: 'app-child',
    template: `
      <p>
      This is the child-component. Current value: {{val}}.
    </p>
    `
  })
  export class ChildComponent implements OnInit { 
    @Input() val: number
  }
\end{lstlisting}


\subsubsection{Have one component configure another one: two-way-binding}
\begin{lstlisting}

  <textComp [textSize]="theTextSize">
  </textComp>

  <integerConfigurer [(confableInt)]="theTextSize">
  </integerConfigurer>

\end{lstlisting}
... or ...
\begin{lstlisting}

  <parentComp>
    <integerConfigurer [(confableInt)]="theParentsTextSize">
    </integerConfigurer>
  </parentComp>

\end{lstlisting}



\subsection{Forms}
Forms are a difficult subject in any framework or library. Angular offers to approaches to handling forms, template-driven (simple) or reactive (larger).

\subsubsection{Template driven forms}
These require little code, but they have a rather cluncky syntax.

\subsubsection{Reactive (f.k.a. model-driven) forms}

\begin{lstlisting}[language=html]
<form [formGroup]="profileForm" (ngSubmit)="onSubmit()">
    <label>
        First Name:
        <input type="text" formControlName="firstName">
      </label>
      <label>
          Last Name:
          <input type="text" formControlName="lastName">
      </label>
      <button type="submit" [disabled]="!profileForm.valid">Submit</button>
</form>
\end{lstlisting}
\begin{lstlisting}[language=java]
import { Component, OnInit } from '@angular/core';
import { FormGroup, FormControl, Validators, ValidatorFn } from '@angular/forms';
    
@Component({
      selector: 'app-profile-editor',
      templateUrl: './profile-editor.component.html',
      styleUrls: ['./profile-editor.component.css']
})
export class ProfileEditorComponent implements OnInit {
    
      profileForm: FormGroup;
    
      constructor() { }
    
      ngOnInit() {
    
        // An example of a custom validator
        let nameMustNotBeBobValidator = function (): ValidatorFn {
          return (control: AbstractControl) => {
            let isValid =  control.value != "Bob";
            if(isValid) return null;
            else return {"MustNotBeBob": "The name must not be Bob!"};
          };
        };
    
        // the form
        this.profileForm = new FormGroup({
          firstName: new FormControl('First name', 
            [Validators.required, Validators.minLength(4), nameMustNotBeBobValidator ]
          ),
          lastName: new FormControl('Last name')
        });
      }
    
      onSubmit() {
        console.warn(this.profileForm.value);
      }
    
}
\end{lstlisting}    


\subsection{External libraries}
\begin{itemize}
  \item Installing library by running: \inlinecode{npm install --save hashwords}
  \item Importing it to the angular.json: \inlinecode{"scripts": ["../node_modules/hashwords/dist/hashwords.min.js"]}. By this action, we made it available on the window object.
  \item Now, we can register it in the providers property of theNgModule: \inlinecode{providers: [\{ provide: 'Hashwords', useValue: window['hashwords']() \}]}
  \item Now we can inject the library in any constructor: \inlinecode{constructor( @Inject('Hashwords') public hashwords: any) \{}
\end{itemize}

\subsection{Libraries}
At some point, you will want to outsource your module(s) into a library.
\begin{lstlisting}
    ng generate library game-utils --prefix=gu
\end{lstlisting}
This creates a \inlinecode{projects} folder.
\begin{lstlisting}
    ng build game-utils
\end{lstlisting}
This builds the library into a npm-package situated in a new \inlinecode{dist} folder.

\subsection{Angular for maps}
Angular's modular design allows us to create a declarative map-API, one where the whole map including markers is defined using html. We let ourselves be inspired by the \inlinecode{@agm} module, which implements google-maps bindings for angular. 
 



\subsection{RxJs: General concepts}

As a singlethreaded, event-based environment, javascript has a bunch of event-based structures built in.

\paragraph{Observables} are objects that maintain a list of subscribers. The subscribers must implement the subscriber-interface, which means that they must have methods \inlinecode{next, completed, error}.
The "notify-all-subscribers" part is handled by an abstract base class from \inlinecode{RxJS}. To create an observable, you only need to pass in a function that tells the observable how to  get its data.



There are multiple types of observables: 
\begin{itemize}
  \item Promise:
    \begin{itemize}
      \item lets you wait for data
      \item however, data is delivered in a single batch - there is no \inlinecode{observer.onCompleted()} method
    \end{itemize}
  \item observable: 
    \begin{itemize}
      \item vs promises:
        \begin{itemize}
          \item observables are like promises, but they can emmit multiple calls to \inlinecode{observer.onNext(data)}, and are cancelable and unsubscribeable.
        \end{itemize}
      \item vs subjects:
        \begin{itemize}
          \item the next method is executed for every subscriber individually as soon as the subscriber subscribes. 
          \item observable cannot subscribe anywhere
        \end{itemize}
    \end{itemize}
  \item subjects:
    \begin{itemize}
      \item the next method is executed at some point, but not neccessarily when a subscriber subscribes. all subscribers receive the same data. 
      \item subjects implement both Obeservable and Observer interface, so they can also subscribe to other Observables if they want to. 
      \item \inlinecode{next} is called from outside the subject, instead of from inside like it is the case with observables. This makes that basically anyone can trigger a broadcast. 
    \end{itemize}
  \item behaviour subjects:
    \begin{itemize}
      \item are subjects that have an initial state. 
    \end{itemize}
\end{itemize}

Subjects are like radio stations: you can tune in at any time, but from that moment on everybody gets the same data.
\begin{lstlisting}[language=java]

let radio = new Subject();

let listener1 = {
    onNext: (nextVal) => console.log("listener1 is hearing: " + nextVal),
    onCompleted: () => console.log("completed"),
    onError: (error) => console.log(error)
};
let session1 = radio.subscribe(listener1);

radio.next('Hello! Youre listening to ...');
// sleep

let listener2 = {
    onNext: (nextVal) => console.log("listener2 is hearing: " + nextVal);
}
let session2 = radio.subscribe(listener2);

radio.next('... RxJs radio!');
// sleep

session1.unsubscribe();
session2.unsubscribe();

\end{lstlisting}

Obeservables are like signing a rent-contract: depending on at what time you sign, your rent may be higher. 
\begin{lstlisting}[language=java]

let landlord = Rx.Observable.create((tenant) => {
    while(true) {
        let currentRent = Math.random();
        tenant.onNext(currentRent);
        // sleep
    }
});


let observer1 = {
    onNext: (nextVal) => console.log(nextVal),
    onCompleted: () => console.log("completed"),
    onError: (error) => console.log(error)
}

let observer2 = {
    onNext: (nextVal) => console.log("blub!");
}

let contract1 = landlord.subscribe(tenant1);
// sleep
let contract2 = landlord.subscribe(tenant2);
// sleep

contract1.unsubscribe();
// sleep
contract2.unsubscribe();

\end{lstlisting}

These subtle differences yield different use-cases: 
\begin{itemize}
    \item To implement a clock, you want to use an observable, that sends you the current time and then an update every n milliseconds. 
    \item To implement a game-loop, you want to use a subject, that sends the call to do \inlinecode{onUpdate} to all observers at the same time. 
    \item To implement a chat-app you want to have a chat-app, where everyone can trigger a \inlinecode{next} when they hit enter. 
\end{itemize}


\paragraph{Observables and threading} do not cover the same usecases. On the contrary, they can be used together very nicely. Threads are there to do things on the side. Observables are there to handle the case where a requested thing might not be available on time. So if your thread might still be hard at work when the main-thread tries to access its results, it might make sense to have the thread return an observable. 