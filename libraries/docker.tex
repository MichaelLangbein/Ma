\section{Docker}

\subsection{When would you want to use docker?}
When you have one host that hosts many processes that are all linux-based, but for the rest should be isolated. 

\subsection{Containers}

\begin{itemize}
    \item an \emph{image} is an executable package that includes everything needed to run an application--the code, a runtime, libraries, environment variables, and configuration files. Includes execution of all \inlinecode{RUN} statements
    \item a \emph{container} is a runtime instance of an image - what the image becomes in memory when executed (that is, an image with state, or a user process). On startup, the \inlinecode{CMD} directive is executed.
\end{itemize}


Containers and virtual machines.
\begin{itemize}
    \item A container runs natively on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.
    \item By contrast, a virtual machine (VM) runs a full-blown “guest” operating system with virtual access to host resources through a hypervisor. In general, VMs provide an environment with more resources than most applications need.
\end{itemize}

Images are described by \emph{Dockerfiles} that list all the contents of an image. These image files can be downloaded from a central repository called \emph{docker hub}.
Usually, you write your own dockerfile that specifies as a dependency a more general dockerfile as your base. 

\begin{lstlisting}[language=bash]
# Use an official Python runtime as a parent image
FROM python:2.7-slim

# Set the working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD ["python", "app.py"]
\end{lstlisting}

You then write your app. 
\begin{lstlisting}[caption=requirements.txt]
Flask
Redis
\end{lstlisting}

\begin{lstlisting}[language=python, caption=main.py]
    from flask import Flask
    from redis import Redis, RedisError
    import os
    import socket
    
    # Connect to Redis
    redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)
    
    app = Flask(__name__)
    
    @app.route("/")
    def hello():
        try:
            visits = redis.incr("counter")
        except RedisError:
            visits = "<i>cannot connect to Redis, counter disabled</i>"
    
        html = "<h3>Hello {name}!</h3>" \
               "<b>Hostname:</b> {hostname}<br/>" \
               "<b>Visits:</b> {visits}"
        return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)
    
    if __name__ == "__main__":
        app.run(host='0.0.0.0', port=80)
\end{lstlisting}

\begin{itemize}
    \item  \inlinecode{sudo docker image build --tag=<nameofyourappalllowercase> .}: package your app and send it to \inlinecode{/var/lib/docker/images}
    \item \inlinecode{sudo docker container run -p 4000:80 -d --name=<nameofyourcontaineralllowercase> <nameofyourappalllowercase>}: execute that package (where \inlinecode{-p 4000:80} means \emph{map the containers port 80 to the systems port 4000} and \inlinecode{-d} stands for \emph{detached}, i.e. get back control of your command-line after starting the container).
    \item \inlinecode{sudo docker image ls}
    \item \inlinecode{sudo docker container ls -a}
    \item \inlinecode{sudo docker image rm <imagename>}
    \item \inlinecode{sudo docker container rm <containername>}
\end{itemize}

Note: \inlinecode{docker run -it ...} creates a new container from an image, \inlinecode{docker start -i ...} starts up an existing container. 


\subsection{Layers}
Each directive in a dockerfile creates a new \emph{layer} (aka. \emph{intermediate image}), which is cached in the engine to speed up the build of other dockerfiles. 
If your build breaks at a certain point in the execution, like this: 

\begin{lstlisting}
    Step 16/25 : RUN cd geoserver.src/src
     ---> Running in dff9e492bfc7
    Removing intermediate container dff9e492bfc7
     ---> 16c2728b1c46
    Step 17/25 : RUN mvn clean install -Pwps,wps-remote,importer -DskipTests
    ---> Running in f102f7633b49
   [INFO] Scanning for projects...
   [INFO] BUILD FAILURE
   [WARNING] The requested profile "wps" could not be activated because it does not exist.
   [WARNING] The requested profile "wps-remote" could not be activated because it does not exist.
   [WARNING] The requested profile "importer" could not be activated because it does not exist.
   [ERROR] The goal you specified requires a project to execute but there is no POM in this directory (/). Please verify you invoked Maven from the correct directory. -> [Help 1]
\end{lstlisting}

You can start the container at the last successful intermediate image like this: 

\begin{lstlisting}
docker image ls 
    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
    <none>              <none>              16c2728b1c46        About an hour ago   1.1GB
docker history 16c2728b1c46
    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    16c2728b1c46        About an hour ago   /bin/sh -c cd geoserver.src/src                 0B
    63bb6b9446f9        About an hour ago   /bin/sh -c source /etc/profile.d/maven.sh       0B
    e236f5e2c9bc        About an hour ago   /bin/sh -c ln -s /opt/apache-maven-3.6.1/ /o... 24B
docker container run --rm -it 16c2728b1c46
\end{lstlisting}

Note the \inlinecode{--rm} argument. This removes a container again once it has stopt running. You can start a very small container for a single instruction and immediately remove it again like this: 

\begin{lstlisting}
docker container run --rm alpine:latest bin/sh -c "whoami"
\end{lstlisting}

\subsection{Volumes}



\subsection{Services and docker-compose}
While \inlinecode{docker} is the basic CLI to control docker, it is more practical to use docker's equivalent of a makefile: a \inlinecode{docker-compose.yml}. In such a file, you
\begin{itemize}
    \item specify a list of \emph{services}. A service is a set of one or more container-instances of one root image. Each service can be configured as follows:
    \begin{itemize}
        \item \inlinecode{build}: path to dockerfile
        \item \inlinecode{ports}: list of portmappings
    \end{itemize}
\end{itemize}


\begin{lstlisting}
version: "3"
services: 
    <imagetag>: 
        build: .
        ports: 
            - "4000:80"
\end{lstlisting}

\begin{itemize}
    \item \inlinecode{sudo docker-compose up -d} (builds and) runs the container(s)
    \item \inlinecode{sudo docker-compose up -d --build} forces a rebuild of all images and runs the containers
    \item \inlinecode{sudo docker-compose down} stops the containers and deletes them (but leaves the images intact)
\end{itemize}
